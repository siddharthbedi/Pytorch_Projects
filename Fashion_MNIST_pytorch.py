# -*- coding: utf-8 -*-
"""Udacity-Image_MNIST.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cIYSXzwWMXdd__kJhzAjtW0iYbuneP3b
"""

import torch
from torchvision import datasets, transforms
from torch import nn
from torch import optim

transform = transforms.Compose([transforms.ToTensor() , transforms.Normalize((0.5,),(0.5,)),])
trainset = trainset = datasets.FashionMNIST('~/.pytorch/F_MNIST_data/', download=True, train=True, transform=transform)
trainloader = torch.utils.data.DataLoader(trainset, batch_size=64, shuffle=True)

testset = datasets.FashionMNIST('~/.pytorch/F_MNIST_data/', download=True, train=False, transform=transform)
testloader = torch.utils.data.DataLoader(testset, batch_size=64, shuffle=True)

#building a forward feed network
model = nn.Sequential(nn.Linear(784,128), nn.ReLU(), nn.Linear(128,64), nn.ReLU() , nn.Linear(64,10), nn.LogSoftmax(dim = 1))

#criterion declaration 
#criterion = nn.NLLLoss()
criterion = nn.CrossEntropyLoss()
optimiser = optim.SGD(model.parameters() , lr = 0.01)

epoch = 25

loss = 0 
for m in range(epoch):
  images, labels = next(iter(trainloader))
  images = images.view(images.shape[0], -1)
  #print(images.shape)
  model.zero_grad()
  output = model.forward(images)
  loss = criterion(output, labels)
  loss.backward()
  optimiser.step()
  print(loss)

# %matplotlib inline
# %config InlineBackend.figure_format = 'retina'

#print(m)
  
  dataiter = iter(testloader)
  images, labels = dataiter.next()
  img = images.view(images.shape[0], -1)
  ps = torch.exp(model(img))



  top_p , top_class = ps.topk(1,dim =1)
  #top_class = top_class[:10, :]
  equals = top_class == labels.view(*top_class.shape)
  #print(equals.shape)
  acc = torch.mean(equals.type(torch.FloatTensor))
  acc = acc.item()*100
  
  plt.scatter(m,acc , s = 10)
plt.show()
print(acc)





