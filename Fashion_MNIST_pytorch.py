# -*- coding: utf-8 -*-
"""Udacity-Image_MNIST.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cIYSXzwWMXdd__kJhzAjtW0iYbuneP3b
"""

import torch
from torchvision import datasets, transforms
from torch import nn
from torch import optim

transform = transforms.Compose([transforms.ToTensor() , transforms.Normalize((0.5,),(0.5,)),])
trainset = trainset = datasets.FashionMNIST('~/.pytorch/F_MNIST_data/', download=True, train=True, transform=transform)
trainloader = torch.utils.data.DataLoader(trainset, batch_size=64, shuffle=True)

testset = datasets.FashionMNIST('~/.pytorch/F_MNIST_data/', download=True, train=False, transform=transform)
testloader = torch.utils.data.DataLoader(testset, batch_size=64, shuffle=True)

#building a forward feed network
model = nn.Sequential(nn.Linear(784,128), nn.ReLU(), nn.Linear(128,64), nn.ReLU() , nn.Linear(64,10), nn.LogSoftmax(dim = 1))

#criterion declaration 
#criterion = nn.NLLLoss()
criterion = nn.CrossEntropyLoss()
optimiser = optim.SGD(model.parameters() , lr = 0.01)

epoch = 25

loss = 0 
for m in range(epoch):
  images, labels = next(iter(trainloader))
  images = images.view(images.shape[0], -1)
  #print(images.shape)
  model.zero_grad()
  output = model.forward(images)
  loss = criterion(output, labels)
  loss.backward()
  optimiser.step()
  print(loss)

# %matplotlib inline
# %config InlineBackend.figure_format = 'retina'

import helper

dataiter = iter(testloader)
images, labels = dataiter.next()
img = images.view(images.shape[0], -1)

ps = torch.exp(model(img))

import matplotlib.pyplot as plt
import numpy as np

def view_classify(img, ps, version):
    ''' Function for viewing an image and it's predicted classes.
    '''
    ps = ps.data.numpy().squeeze()

    fig, (ax1, ax2) = plt.subplots(figsize=(6,9), ncols=2)
    ax1.imshow(img.resize_(1, 28, 28).numpy().squeeze())
    ax1.axis('off')
    ax2.barh(np.arange(10), ps)
    ax2.set_aspect(0.1)
    ax2.set_yticks(np.arange(10))
    if version == "MNIST":
        ax2.set_yticklabels(np.arange(10))
    elif version == "Fashion":
        ax2.set_yticklabels(['T-shirt/top',
                            'Trouser',
                            'Pullover',
                            'Dress',
                            'Coat',
                            'Sandal',
                            'Shirt',
                            'Sneaker',
                            'Bag',
                            'Ankle Boot'], size='small');
    ax2.set_title('Class Probability')
    ax2.set_xlim(0, 1.1)

plt.tight_layout()

view_classify(img,ps,version = 'Fashion')



